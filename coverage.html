
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>middleware: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/WebDeveloperBen/ai-gateway/internal/gateway/middleware/policy_enforcement.go (100.0%)</option>
				
				<option value="file1">github.com/WebDeveloperBen/ai-gateway/internal/gateway/middleware/request_buffer.go (100.0%)</option>
				
				<option value="file2">github.com/WebDeveloperBen/ai-gateway/internal/gateway/middleware/usage_recording.go (85.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package middleware provides HTTP middleware for the gateway
package middleware

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/auth"
        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/policies"
        "github.com/WebDeveloperBen/ai-gateway/internal/logger"
)

// PolicyLoader defines the interface for loading policies
type PolicyLoader interface {
        LoadPolicies(ctx context.Context, appID string) ([]policies.Policy, error)
}

// PolicyEnforcer provides policy enforcement for requests
type PolicyEnforcer struct {
        engine PolicyLoader
}

// NewPolicyEnforcer creates a new policy enforcer
func NewPolicyEnforcer(engine PolicyLoader) *PolicyEnforcer <span class="cov7" title="8">{
        return &amp;PolicyEnforcer{
                engine: engine,
        }
}</span>

// Middleware returns a RoundTripper middleware that enforces policies
func (pe *PolicyEnforcer) Middleware(next http.RoundTripper) http.RoundTripper <span class="cov7" title="7">{
        return roundTripFunc(func(r *http.Request) (*http.Response, error) </span><span class="cov7" title="7">{
                ctx := r.Context()

                // Fast path: Skip policy enforcement if app context is missing
                // This indicates the request is not an LLM request (auth middleware not applied)
                appID := auth.GetAppID(ctx)
                if appID == "" </span><span class="cov1" title="1">{
                        return next.RoundTrip(r)
                }</span>

                // Load policies for this app
                <span class="cov6" title="6">policyList, err := pe.engine.LoadPolicies(ctx, appID)
                if err != nil </span><span class="cov1" title="1">{
                        logger.GetLogger(ctx).Error().
                                Err(err).
                                Str("app_id", appID).
                                Msg("Failed to load policies for enforcement")
                        return deny(500, "failed to load policies"), nil
                }</span>

                // Store policies in context for usage recording middleware
                <span class="cov6" title="5">ctx = auth.WithPolicies(ctx, policyList)
                r = r.WithContext(ctx)

                // Get pre-parsed request data from context
                // No more JSON unmarshaling, no more body access!
                parsedReq := auth.GetParsedRequest(ctx)
                if parsedReq == nil </span><span class="cov1" title="1">{
                        // This shouldn't happen if RequestBuffer middleware ran
                        logger.GetLogger(ctx).Error().
                                Str("app_id", appID).
                                Msg("Missing parsed request data")
                        return deny(500, "internal error"), nil
                }</span>

                // Build pre-request context using parsed data
                <span class="cov5" title="4">preCtx := &amp;policies.PreRequestContext{
                        Request:          r,
                        OrgID:            auth.GetOrgID(ctx),
                        AppID:            appID,
                        APIKeyID:         auth.GetKeyID(ctx),
                        Model:            parsedReq.Model,
                        EstimatedTokens:  parsedReq.EstimatedTokens,
                        RequestSizeBytes: parsedReq.RequestSize,
                        Body:             nil, // No longer needed - policies use parsed data
                }

                // Run pre-checks (blocking)
                for _, policy := range policyList </span><span class="cov6" title="5">{
                        if err := policy.PreCheck(ctx, preCtx); err != nil </span><span class="cov3" title="2">{
                                logger.GetLogger(ctx).Warn().
                                        Err(err).
                                        Str("app_id", appID).
                                        Str("org_id", auth.GetOrgID(ctx)).
                                        Str("policy_type", string(policy.Type())).
                                        Str("model", parsedReq.Model).
                                        Int("estimated_tokens", parsedReq.EstimatedTokens).
                                        Msg("Policy check failed")
                                return deny(429, "policy violation"), nil
                        }</span>
                }

                // Continue with request
                <span class="cov3" title="2">return next.RoundTrip(r)</span>
        })
}

// roundTripFunc is a type adapter for http.RoundTripper
type roundTripFunc func(*http.Request) (*http.Response, error)

func (f roundTripFunc) RoundTrip(r *http.Request) (*http.Response, error) <span class="cov10" title="18">{
        return f(r)
}</span>

// deny creates an error response
func deny(code int, msg string) *http.Response <span class="cov7" title="7">{
        return &amp;http.Response{
                StatusCode: code,
                Status:     fmt.Sprintf("%d %s", code, http.StatusText(code)),
                Header:     http.Header{"Content-Type": []string{"application/problem+json"}},
                Body:       io.NopCloser(strings.NewReader(fmt.Sprintf(`{"title":"%s","status":%d}`, msg, code))),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net/http"

        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/auth"
        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/tokens"
)

// RequestBuffer buffers and parses the request body once
type RequestBuffer struct {
        estimator *tokens.Estimator
}

// NewRequestBuffer creates a new request buffer middleware
func NewRequestBuffer() *RequestBuffer <span class="cov5" title="3">{
        return &amp;RequestBuffer{
                estimator: tokens.NewEstimator(),
        }
}</span>

// Middleware returns a RoundTripper middleware that buffers and parses the request body
func (rb *RequestBuffer) Middleware(next http.RoundTripper) http.RoundTripper <span class="cov7" title="5">{
        return roundTripFunc(func(r *http.Request) (*http.Response, error) </span><span class="cov7" title="5">{
                // Read request body once
                var bodyBytes []byte
                if r.Body != nil </span><span class="cov7" title="5">{
                        var err error
                        bodyBytes, err = io.ReadAll(r.Body)
                        if err != nil </span><span class="cov1" title="1">{
                                return deny(400, "failed to read request body"), nil
                        }</span>
                        <span class="cov6" title="4">r.Body.Close()</span>
                }

                // Replace body with a fresh reader for upstream
                <span class="cov6" title="4">r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

                // Parse request ONCE and extract all needed data
                parsed := rb.parseRequest(r.Context(), bodyBytes)

                // Store parsed request in context (small struct, not full body)
                ctx := auth.WithParsedRequest(r.Context(), parsed)
                r = r.WithContext(ctx)

                return next.RoundTrip(r)</span>
        })
}

// parseRequest parses the LLM request body and extracts all needed information
func (rb *RequestBuffer) parseRequest(ctx context.Context, body []byte) *auth.ParsedRequest <span class="cov10" title="9">{
        parsed := &amp;auth.ParsedRequest{
                RequestSize: len(body),
        }

        if len(body) == 0 </span><span class="cov3" title="2">{
                return parsed
        }</span>

        // Parse JSON once into full structure
        <span class="cov8" title="7">var req struct {
                Model    string `json:"model"`
                Messages []struct {
                        Role    string `json:"role"`
                        Content string `json:"content"`
                } `json:"messages,omitempty"`
                Prompt string `json:"prompt,omitempty"`
        }

        if err := json.Unmarshal(body, &amp;req); err != nil </span><span class="cov3" title="2">{
                // If parsing fails, return partial data
                return parsed
        }</span>

        // Extract model
        <span class="cov7" title="5">parsed.Model = req.Model

        // Convert messages
        if len(req.Messages) &gt; 0 </span><span class="cov5" title="3">{
                parsed.Messages = make([]auth.Message, len(req.Messages))
                for i, msg := range req.Messages </span><span class="cov8" title="7">{
                        parsed.Messages[i] = auth.Message{
                                Role:    msg.Role,
                                Content: msg.Content,
                        }
                }</span>
        }

        // Extract prompt (for completion endpoints)
        <span class="cov7" title="5">parsed.Prompt = req.Prompt

        // Estimate tokens using the parsed data
        estimatedTokens, err := rb.estimator.EstimateRequest(ctx, parsed.Model, body)
        if err == nil </span><span class="cov7" title="5">{
                parsed.EstimatedTokens = estimatedTokens
        }</span>

        <span class="cov7" title="5">return parsed</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "bytes"
        "context"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/WebDeveloperBen/ai-gateway/internal/db"
        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/auth"
        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/policies"
        "github.com/WebDeveloperBen/ai-gateway/internal/gateway/tokens"
        "github.com/WebDeveloperBen/ai-gateway/internal/logger"
        "github.com/WebDeveloperBen/ai-gateway/internal/model"
        "github.com/WebDeveloperBen/ai-gateway/internal/observability"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

// responseBodyWrapper wraps the response body to capture the full content before async processing
type responseBodyWrapper struct {
        originalBody io.ReadCloser
        onClose      func([]byte)
        body         *bytes.Buffer
        closed       bool
}

// Read implements io.Reader for the response body
func (rbw *responseBodyWrapper) Read(p []byte) (n int, err error) <span class="cov6" title="21">{
        if rbw.closed </span><span class="cov2" title="2">{
                return 0, http.ErrBodyReadAfterClose
        }</span>
        <span class="cov6" title="19">n, err = rbw.originalBody.Read(p)
        if n &gt; 0 </span><span class="cov5" title="15">{
                rbw.body.Write(p[:n])
        }</span>
        <span class="cov6" title="19">if err != nil </span><span class="cov4" title="7">{
                rbw.close()
        }</span>
        <span class="cov6" title="19">return n, err</span>
}

// Close implements io.Closer for the response body
func (rbw *responseBodyWrapper) Close() error <span class="cov5" title="10">{
        if rbw.closed </span><span class="cov4" title="7">{
                return nil
        }</span>
        <span class="cov2" title="3">rbw.close()
        return rbw.originalBody.Close()</span>
}

// close captures the full body and calls the onClose callback
func (rbw *responseBodyWrapper) close() <span class="cov5" title="10">{
        if rbw.closed </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="10">rbw.closed = true
        bodyBytes := rbw.body.Bytes()
        rbw.onClose(bodyBytes)</span>
}

// UsageRecorder records usage metrics and runs post-check policies
type UsageRecorder struct {
        db     *db.Queries
        parser *tokens.Parser
        engine *policies.Engine
}

// NewUsageRecorder creates a new usage recorder
func NewUsageRecorder(database *db.Queries, engine *policies.Engine) *UsageRecorder <span class="cov3" title="4">{
        return &amp;UsageRecorder{
                db:     database,
                parser: tokens.NewParser(),
                engine: engine,
        }
}</span>

// Middleware returns a RoundTripper middleware that records usage asynchronously
func (ur *UsageRecorder) Middleware(next http.RoundTripper) http.RoundTripper <span class="cov4" title="6">{
        return roundTripFunc(func(r *http.Request) (*http.Response, error) </span><span class="cov4" title="6">{
                // Capture request metadata
                ctx := r.Context()

                // Get request size from parsed request data
                parsedReq := auth.GetParsedRequest(ctx)
                requestSizeBytes := 0
                if parsedReq != nil </span><span class="cov0" title="0">{
                        requestSizeBytes = parsedReq.RequestSize
                }</span>

                // Capture start time
                <span class="cov4" title="6">startTime := time.Now()

                // Execute request
                resp, err := next.RoundTrip(r)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, err
                }</span>

                // Capture latency
                <span class="cov4" title="6">latencyMs := time.Since(startTime).Milliseconds()

                // Extract provider and model from context
                provider := auth.GetProvider(ctx)
                modelName := auth.GetModelName(ctx)

                // Create detached context for async processing
                detachedCtx := detachContext(ctx)

                // Wrap the response body to capture the full content before async processing
                resp.Body = &amp;responseBodyWrapper{
                        originalBody: resp.Body,
                        body:         &amp;bytes.Buffer{},
                        onClose: func(bodyBytes []byte) </span><span class="cov4" title="6">{
                                // Launch async processing after response is fully consumed
                                go ur.recordAsync(detachedCtx, &amp;asyncRecordParams{
                                        provider:         provider,
                                        modelName:        modelName,
                                        requestSizeBytes: requestSizeBytes,
                                        latencyMs:        latencyMs,
                                        request:          r,
                                        response:         resp,
                                        capturedBytes:    bytes.NewBuffer(bodyBytes),
                                })
                        }</span>,
                }

                // Return the response with wrapped body
                <span class="cov4" title="6">return resp, nil</span>
        })
}

// asyncRecordParams holds parameters for async recording
type asyncRecordParams struct {
        provider         string
        modelName        string
        requestSizeBytes int
        latencyMs        int64
        request          *http.Request
        response         *http.Response
        capturedBytes    *bytes.Buffer
}

// recordAsync performs the actual recording in a goroutine
// This runs AFTER the response has been consumed by the client
func (ur *UsageRecorder) recordAsync(ctx context.Context, params *asyncRecordParams) <span class="cov4" title="6">{
        // Wait a bit to ensure response body has been consumed
        // This allows TeeReader to capture the full response
        time.Sleep(10 * time.Millisecond)

        // Extract IDs from detached context
        orgID := getDetachedOrgID(ctx)
        appID := getDetachedAppID(ctx)
        apiKeyID := getDetachedKeyID(ctx)

        // Get captured response bytes
        respBodyBytes := params.capturedBytes.Bytes()
        responseSizeBytes := len(respBodyBytes)

        // Parse token usage from captured response
        tokenUsage, err := ur.parseTokenUsage(params.provider, respBodyBytes)
        if err != nil </span><span class="cov1" title="1">{
                // If parsing fails, use zeros (some responses may not have usage)
                tokenUsage = &amp;model.TokenUsage{
                        PromptTokens:     0,
                        CompletionTokens: 0,
                        TotalTokens:      0,
                }
        }</span>

        // Parse UUIDs
        <span class="cov4" title="6">orgUUID, err := uuid.Parse(orgID)
        if err != nil </span><span class="cov2" title="2">{
                logger.GetLogger(ctx).Error().
                        Err(err).
                        Str("org_id", orgID).
                        Msg("Failed to parse org ID for usage metric")
                return
        }</span>

        <span class="cov3" title="4">appUUID, err := uuid.Parse(appID)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger(ctx).Error().
                        Err(err).
                        Str("app_id", appID).
                        Msg("Failed to parse app ID for usage metric")
                return
        }</span>

        <span class="cov3" title="4">apiKeyUUID, err := uuid.Parse(apiKeyID)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger(ctx).Error().
                        Err(err).
                        Str("api_key_id", apiKeyID).
                        Msg("Failed to parse API key ID for usage metric")
                return
        }</span>

        // Insert usage metric
        <span class="cov3" title="4">_, err = ur.db.CreateUsageMetric(ctx, db.CreateUsageMetricParams{
                OrgID:             orgUUID,
                AppID:             appUUID,
                ApiKeyID:          apiKeyUUID,
                ModelID:           nil,
                Provider:          params.provider,
                ModelName:         params.modelName,
                PromptTokens:      int32(tokenUsage.PromptTokens),
                CompletionTokens:  int32(tokenUsage.CompletionTokens),
                TotalTokens:       int32(tokenUsage.TotalTokens),
                RequestSizeBytes:  int32(params.requestSizeBytes),
                ResponseSizeBytes: int32(responseSizeBytes),
                Timestamp: pgtype.Timestamptz{
                        Time:  time.Now(),
                        Valid: true,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger(ctx).Error().
                        Err(err).
                        Str("org_id", orgID).
                        Str("app_id", appID).
                        Str("provider", params.provider).
                        Str("model", params.modelName).
                        Int("total_tokens", tokenUsage.TotalTokens).
                        Msg("Failed to create usage metric")
                return
        }</span>

        // Get policies from context (already loaded in enforcement middleware)
        <span class="cov3" title="4">policyListInterface := auth.GetPolicies(ctx)
        if policyListInterface == nil </span><span class="cov3" title="4">{
                // Fallback: load policies if not in context
                // This shouldn't normally happen but provides safety
                var err error
                policyListInterface, err = ur.engine.LoadPolicies(ctx, appID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.GetLogger(ctx).Error().
                                Err(err).
                                Str("app_id", appID).
                                Msg("Failed to load policies for post-check")
                        return
                }</span>
        }

        // Type assert to policy list
        <span class="cov3" title="4">policyList, ok := policyListInterface.([]policies.Policy)
        if !ok </span><span class="cov0" title="0">{
                logger.GetLogger(ctx).Error().
                        Str("app_id", appID).
                        Msg("Invalid policy list type in context")
                return
        }</span>

        // Build post-request context
        <span class="cov3" title="4">postCtx := &amp;policies.PostRequestContext{
                Request:           params.request,
                Response:          params.response,
                OrgID:             orgID,
                AppID:             appID,
                APIKeyID:          apiKeyID,
                Provider:          params.provider,
                ModelName:         params.modelName,
                ActualTokens:      *tokenUsage,
                RequestSizeBytes:  params.requestSizeBytes,
                ResponseSizeBytes: responseSizeBytes,
                LatencyMs:         params.latencyMs,
        }

        // Record LLM token metrics
        observability.FromContext(ctx).RecordLLMTokens(
                ctx,
                params.provider,
                params.modelName,
                tokenUsage.PromptTokens,
                tokenUsage.CompletionTokens,
                tokenUsage.TotalTokens,
        )

        // Run post-checks (non-blocking, for logging/metrics)
        for _, policy := range policyList </span><span class="cov3" title="4">{
                policy.PostCheck(ctx, postCtx)
        }</span>
}

// parseTokenUsage handles both regular and streaming responses
func (ur *UsageRecorder) parseTokenUsage(provider string, respBodyBytes []byte) (*model.TokenUsage, error) <span class="cov5" title="13">{
        // First try parsing as a regular response
        usage, err := ur.parser.ParseResponse(provider, respBodyBytes)
        if err == nil </span><span class="cov2" title="3">{
                return usage, nil
        }</span>

        // If that fails, try parsing as streaming response
        // Split by SSE event boundaries
        <span class="cov5" title="10">bodyStr := string(respBodyBytes)
        lines := strings.Split(bodyStr, "\n")

        var chunks [][]byte
        var currentChunk []string

        for _, line := range lines </span><span class="cov10" title="156">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov8" title="79">{
                        // Empty line indicates end of chunk
                        if len(currentChunk) &gt; 0 </span><span class="cov8" title="71">{
                                chunkData := strings.Join(currentChunk, "\n")
                                if strings.HasPrefix(chunkData, "data: ") </span><span class="cov8" title="71">{
                                        // Extract JSON part after "data: "
                                        jsonData := strings.TrimPrefix(chunkData, "data: ")
                                        if jsonData != "[DONE]" </span><span class="cov8" title="64">{
                                                chunks = append(chunks, []byte(jsonData))
                                        }</span>
                                }
                                <span class="cov8" title="71">currentChunk = nil</span>
                        }
                } else<span class="cov8" title="77"> {
                        currentChunk = append(currentChunk, line)
                }</span>
        }

        // Handle any remaining chunk
        <span class="cov5" title="10">if len(currentChunk) &gt; 0 </span><span class="cov2" title="2">{
                chunkData := strings.Join(currentChunk, "\n")
                if strings.HasPrefix(chunkData, "data: ") </span><span class="cov0" title="0">{
                        jsonData := strings.TrimPrefix(chunkData, "data: ")
                        if jsonData != "[DONE]" </span><span class="cov0" title="0">{
                                chunks = append(chunks, []byte(jsonData))
                        }</span>
                }
        }

        // Try parsing chunks for streaming usage
        <span class="cov5" title="10">return ur.parser.ParseStreamedResponse(provider, chunks)</span>
}

type detachedContextKey struct{}

type detachedData struct {
        OrgID     string
        AppID     string
        KeyID     string
        UserID    string
        Provider  string
        ModelName string
}

// detachContext creates a new context that won't be canceled when the parent is
// Uses a single context value to reduce allocations (1 instead of 6)
func detachContext(parent context.Context) context.Context <span class="cov4" title="7">{
        data := &amp;detachedData{
                OrgID:     auth.GetOrgID(parent),
                AppID:     auth.GetAppID(parent),
                KeyID:     auth.GetKeyID(parent),
                UserID:    auth.GetUserID(parent),
                Provider:  auth.GetProvider(parent),
                ModelName: auth.GetModelName(parent),
        }
        return context.WithValue(context.Background(), detachedContextKey{}, data)
}</span>

// Helper functions to get values from detached context
func getDetachedOrgID(ctx context.Context) string <span class="cov4" title="8">{
        if data, ok := ctx.Value(detachedContextKey{}).(*detachedData); ok </span><span class="cov4" title="7">{
                return data.OrgID
        }</span>
        <span class="cov1" title="1">return auth.GetOrgID(ctx)</span>
}

func getDetachedAppID(ctx context.Context) string <span class="cov4" title="8">{
        if data, ok := ctx.Value(detachedContextKey{}).(*detachedData); ok </span><span class="cov4" title="7">{
                return data.AppID
        }</span>
        <span class="cov1" title="1">return auth.GetAppID(ctx)</span>
}

func getDetachedKeyID(ctx context.Context) string <span class="cov4" title="8">{
        if data, ok := ctx.Value(detachedContextKey{}).(*detachedData); ok </span><span class="cov4" title="7">{
                return data.KeyID
        }</span>
        <span class="cov1" title="1">return auth.GetKeyID(ctx)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
