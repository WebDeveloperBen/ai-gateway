# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an **LLM Gateway/Proxy Platform** that intermediates application traffic to Azure OpenAI and OpenAI providers. It provides OpenAI-compatible endpoints while centralizing security, governance, cost controls, and observability.

The system consists of:
- **Go Backend (Data Plane)**: Proxy service with authentication, rate limiting, and request forwarding at `/cmd/proxy/main.go`
- **Nuxt UI (Admin Plane)**: Admin interface for key management, routing rules, and dashboards in `/ui/`
- **Database Layer**: PostgreSQL with Atlas schema definitions (HCL), Goose migrations, and SQLC-generated queries

## Development Commands

### Backend (Go)
```bash
# Run with hot reload (requires Docker for dependencies)
task run

# Build binary (outputs to ./bin/api)
task build

# Format Go code
go fmt ./...

# Lint Go code (if golangci-lint is installed)
golangci-lint run

# Run all tests
task tests

# Run specific test
go test -v ./internal/api/auth/...

# Run tests in a single package
go test -v ./internal/gateway/

# Database schema management (Atlas + Goose)
task db:status                           # Show Atlas diff (DB vs HCL schema)
task db:migrate:diff -- migration_name   # Generate Goose migration from Atlas diff
task db:migrate:apply                    # Apply pending Goose migrations
task db:migrate:status                   # Show Goose migration status (applied/pending)
task db:migrate:new -- migration_name    # Generate AND apply migration in one step
task db:reset                            # Reset database (drops data!) and apply schema

# Generate SQLC code from queries
task generate

# Stop development environment
task stop
```

### Frontend (UI)
```bash
cd ui/

# Development server
pnpm dev

# Build for production
pnpm build

# Generate static site
pnpm generate

# Preview production build
pnpm preview

# Format code (prettier)
pnpm format

# Lint code (if eslint is configured)
pnpm lint

# Type check
pnpm build
```

## Architecture

### Go Backend Structure
- **`cmd/proxy/main.go`**: Main application entry point
- **`cmd/migrate/main.go`**: Standalone migration runner
- **`internal/api/`**: HTTP API routes and handlers
  - `admin/`: Admin API endpoints (keys, users, roles)
  - `auth/`: OIDC authentication routes
  - `gateway/`: Proxy endpoint handlers
  - `middleware/`: Authentication and request processing middleware
- **`internal/gateway/`**: Core proxy logic
  - `auth/`: API key authentication
  - `policies/`: Request policies (WIP)
  - `loadbalancing/`: Load balancing strategies (WIP)
  - `ratelimiter/`: Rate limiting (WIP)
  - Registry pattern for model deployments
- **`internal/model/`**: Core domain models and repository interfaces
- **`internal/repository/`**: Repository implementations (Postgres/Memory) implementing `internal/model/` interfaces
- **`internal/drivers/`**: Database (PostgreSQL) and KV store (Redis/Memory) drivers
- **`internal/provider/`**: Provider adapters (Azure OpenAI, OpenAI)
- **`internal/db/`**: SQLC-generated database code (auto-generated, do not edit)
- **`internal/migrate/`**: Database migration runtime logic
- **`db/`**: Database schema (HCL), migrations (Goose), and queries (SQLC)

### Frontend Structure
- **Nuxt 4** with TypeScript
- **TailwindCSS** for styling with **Reka UI** components
- **Vue Query** for API state management
- **Vee-validate + Zod** for form validation
- Pages in `ui/app/pages/(dashboard)/` use file-based routing

### Key Dependencies
- **Huma v2**: API framework with OpenAPI generation
- **Chi**: HTTP router
- **PGX v5**: PostgreSQL driver
- **Redis**: Rate limiting and caching
- **SQLC**: Type-safe SQL code generation
- **Zerolog**: Structured logging

## Database

### Schema Management
- **Atlas-Managed Schema**: Schema is defined declaratively in HCL files in `db/schema/` directory
- **Atlas → Goose Pipeline**: Atlas generates versioned Goose migrations from HCL schema changes
- **Migration Execution**: Goose runs migrations at runtime (app startup) and in CI/CD (Container App jobs)
- **Never Edit Migrations**: Once generated by Atlas, migration files in `db/migrations/` are immutable
- **SQLC Integration**: Generates type-safe Go code from SQL queries in `db/queries/`
- **Pre/Post Scripts**: PostgreSQL extensions, functions, and triggers managed in `db/schema_pre.sql` and `db/schema_post.sql`

### Why This Approach?
- **Declarative Schema**: Define what the schema should be, not how to change it
- **Automatic Migrations**: Atlas diffs current DB state vs. HCL schema and generates migration SQL
- **Version Control**: Goose provides versioned migration tracking for production deployments
- **No Manual SQL**: Eliminates hand-written migration SQL which is error-prone

### Common Patterns
- **Repository Pattern**: All repositories implement interfaces defined in `internal/model/`, with concrete implementations in `internal/repository/`
- **Factory Pattern**: Repository instantiation uses factory functions (e.g., `keyrepo.NewKeyRepository`) with `model.RepositoryConfig`
- **Error Handling**: Use `internal/exceptions/` for standardized error handling and HTTP error responses
- **Database Access**: Never write raw SQL in Go code—use SQLC-generated functions from `internal/db/`
- **Transactions**: Handled via repository methods that accept `pgx.Tx`
- **IDs**: UUID primary keys with ULID generation via `oklog/ulid/v2`

## Configuration

### Environment Variables
Set in `.env` file (see existing `.env` for reference):
- Database: `POSTGRES_DSN`
- Redis: `REDIS_ADDR`, `REDIS_PW` 
- Auth: `APP_REGISTRATION_*` variables for Azure AD
- Proxy: `PROXY_PORT`

### Build Configuration
- **Air**: Hot reload configuration in `.air.toml`
- **TaskFile**: Task runner configuration in `TaskFile.yml`
- **Docker**: Uses `compose.yml` for local dependencies

## Provider Integration

### Adding New Providers
1. Create new directory in `internal/provider/` (e.g., `internal/provider/anthropic/`)
2. Implement `internal/provider/Provider` interface with request/response transformation
3. Add provider-specific configuration in `internal/model/`
4. Register in `cmd/proxy/main.go` via `apigw.RegisterProvider()`
5. Add provider prefix constant and route registration

### Existing Providers
- **Azure OpenAI**: Handles model mapping to Azure deployments
- **OpenAI**: Direct OpenAI API integration

## Security

- API keys stored hashed using Argon2ID
- OIDC integration with Azure AD for admin UI
- Secret references pattern (avoid storing raw secrets)
- Request/response logging with configurable redaction

## Testing

- Test files alongside source code (`*_test.go`)
- Use `internal/testkit/` for test utilities
- Run with `task tests` or `go test ./...`

## Development Workflow

### Initial Setup
1. Copy `.env.example` to `.env` and configure variables
2. Start dependencies: `task run` (starts Docker services + hot reload)
3. Migrations run automatically on app startup

### Daily Development
1. Backend changes: Hot reload via Air (already running with `task run`)
2. Frontend: `cd ui && pnpm dev` (separate terminal)
3. Database schema changes:
   - Edit HCL files in `db/schema/`
   - Generate migration: `task db:migrate:diff -- migration_name`
   - Apply: `task db:migrate:apply` (or restart app)
   - Regenerate SQLC: `task generate`
4. Tests: `task tests`

### Database Workflow
**Critical**: Schema changes MUST flow through Atlas → Goose → SQLC. Never write manual migrations.

1. **Define Schema**: Edit/add HCL files in `db/schema/` (e.g., `db/schema/users.hcl`)
2. **Check Changes**: `task db:status` shows diff between DB and schema
3. **Generate Migration**: `task db:migrate:diff -- descriptive_name` creates Goose migration SQL from Atlas diff
4. **Apply Migration**:
   - Dev: `task db:migrate:apply` or restart app (auto-applies on startup)
   - Prod: CI/CD runs Goose migrations via Container App job
5. **Update SQLC**: `task generate` regenerates type-safe Go code from new schema

**Important Notes**:
- Never edit generated migration files in `db/migrations/`—they're versioned and immutable
- Atlas looks at HCL schema as source of truth, not the SQL migrations
- If you need to add custom SQL (functions, triggers), use `db/schema_pre.sql` or `db/schema_post.sql`

## Vue/Nuxt Component Conventions

### Component Structure
- **Script tag placement**: Always place `<script setup>` tag BEFORE `<template>` tag in Vue components
- **Component order**: Use the following structure:
  1. `<script setup lang="ts">` 
  2. `<template>`
  3. `<style>` (if needed)

### Code Style
- **Component naming**: Use PascalCase for component files and imports
- **Prop definitions**: Use TypeScript interfaces for component props with JSDoc documentation
- **Template simplicity**: Prefer direct property access in templates over helper functions when possible
- **DRY Components**: Create reusable components for common patterns (e.g., `ChartPlaceholder`, `RecentActivity`)
- **DO NOT ADD COMMENTS** unless explicitly requested