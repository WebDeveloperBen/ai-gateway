version: "3"

dotenv: [".env"]

tasks:
  default:
    cmds:
      - task dev

  build:
    desc: Build the Go application binary
    cmds:
      - go build -o ./bin/proxy ./cmd/proxy

  dev:
    desc: Run the application in development mode with hot reloading
    cmds:
      - echo "🚀 Starting development environment..."
      - docker compose up -d
      - task wait-for-db
      - echo "📦 Running migrations..."
      - task migrate
      - echo "🔥 Starting Air hot reload..."
      - air

  run:
    desc: Run the application binary (production mode)
    cmds:
      - ./bin/proxy

  migrate:
    desc: Run database migrations
    cmds:
      - go run ./cmd/migrate/main.go

  wait-for-db:
    desc: Wait for database to be ready
    cmds:
      - |
        echo "Waiting for database to be ready..."
        for i in {1..30}; do
          if pg_isready -h localhost -p 5432 -U system -d system >/dev/null 2>&1; then
            echo "Database is ready!"
            exit 0
          fi
          echo "Waiting for database... ($i/30)"
          sleep 2
        done
        echo "Database failed to start"
        exit 1

  stop:
    desc: Stop the Docker Compose environment
    cmds:
      - docker compose down

  tests:
    desc: Run all Go tests
    cmds:
      - go test -v ./...

    # -------------------
    # Coverage tasks
    # -------------------

  coverage:
    desc: Run tests with coverage excluding SQLC generated code and show summary
    cmds:
      - go test -coverprofile=coverage.out $(go list ./... | grep -v internal/db)
      - go tool cover -func=coverage.out | tail -1

  coverage:html:
    desc: Generate and open HTML coverage report excluding SQLC generated code
    cmds:
      - go test -coverprofile=coverage.out $(go list ./... | grep -v internal/db)
      - go tool cover -html=coverage.out -o coverage.html
      - |
        echo "✅ Coverage report: coverage.html"

  coverage:check:
    desc: Check if coverage meets 80% threshold (excluding SQLC generated code)
    cmds:
      - go test -coverprofile=coverage.out $(go list ./... | grep -v internal/db)
      - |
        COVERAGE=$(go tool cover -func=coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')
        echo "Project coverage (excluding SQLC): ${COVERAGE}%"
        if (( $(echo "$COVERAGE < 80" | bc -l) )); then
          echo "❌ Coverage below 80%"
          exit 1
        fi
        echo "✅ Coverage meets threshold"

  # -------------------
  # Benchmarking tasks
  # -------------------

  bench:
    desc: Run benchmarks for key packages
    cmds:
      - go test -bench=. -benchmem -benchtime=1s ./internal/...

  bench:save:
    desc: Save current benchmark as baseline for comparison
    cmds:
      - go test -bench=. -benchmem ./internal/... > bench-baseline.txt
      - echo "✅ Baseline saved to bench-baseline.txt"

  bench:compare:
    desc: Compare current benchmarks against baseline
    cmds:
      - go test -bench=. -benchmem ./internal/... > bench-current.txt
      - benchstat bench-baseline.txt bench-current.txt

  # -------------------
  # Atlas database tasks
  # -------------------

  db:status:
    desc: Show schema status and diff
    cmds:
      - atlas schema diff --from "$ATLAS_DATABASE_URL" --to file://db/schema

  db:apply:
    desc: Apply schema changes directly (DEV ONLY - non-versioned)
    cmds:
      - psql "$POSTGRES_DSN" -f db/schema_pre.sql
      - atlas schema apply --to file://db/schema --url "$ATLAS_DATABASE_URL" --auto-approve
      - psql "$POSTGRES_DSN" -f db/schema_post.sql

  db:migrate:diff:
    desc: Generate Goose migration from schema changes
    cmds:
      - atlas migrate diff --env local {{.CLI_ARGS | default "auto_migration"}}

  db:migrate:apply:
    desc: Apply pending Goose migrations (what your app runs)
    cmds:
      - psql "$POSTGRES_DSN" -f db/schema_pre.sql
      - goose -dir ./db/migrations postgres "$POSTGRES_DSN" up
      - psql "$POSTGRES_DSN" -f db/schema_post.sql

  db:migrate:new:
    desc: Create and apply new Goose migration from schema changes
    cmds:
      - atlas migrate diff --env local {{.CLI_ARGS | default "auto_migration"}}

  db:migrate:status:
    desc: Show Goose migration status
    cmds:
      - goose -dir ./db/migrations postgres "$POSTGRES_DSN" status

  db:plan:
    desc: Plan schema changes (dry run)
    cmds:
      - atlas schema plan --from "$ATLAS_DATABASE_URL" --to file://db/schema

  db:inspect:
    desc: Inspect current database schema
    cmds:
      - atlas schema inspect --url "$ATLAS_DATABASE_URL"

  db:reset:
    desc: Reset database and apply schema
    cmds:
      - docker compose down -v
      - docker compose up -d postgres
      - sleep 3
      - psql "$POSTGRES_DSN" -f db/schema_pre.sql
      - atlas schema apply --to file://db/schema --url "$ATLAS_DATABASE_URL" --auto-approve
      - psql "$POSTGRES_DSN" -f db/schema_post.sql

  # -------------------
  # SQLC generation
  # -------------------

  generate:
    desc: Generate SQLC code from queries
    cmds:
      - atlas schema inspect --url "$ATLAS_DATABASE_URL" --exclude goose_db_version --format '{{"{{ sql . }}"}}' > db/schema.sql
      - rm -rf ./internal/db && sqlc generate -f ./db/sqlc.yml

  generate:sqlc:
    desc: Generate only SQLC code (without schema update)
    cmds:
      - rm -rf ./internal/db && sqlc generate -f ./db/sqlc.yml

  clean:migrations:
    desc: Remove all migration files (careful!)
    cmds:
      - rm -rf ./db/migrations/*
