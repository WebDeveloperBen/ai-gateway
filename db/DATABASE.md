# Database Schema Management

This project uses **Atlas** for schema management, **Goose** for versioned migrations, and **SQLC** for type-safe Go code generation.

## Architecture

- **HCL Schema Files** (`db/schema/*.hcl`) - Declarative schema definition
- **Atlas** - Generates Goose migrations from HCL schema changes
- **Goose** - Applies versioned migrations to the database
- **SQLC** - Generates type-safe Go code from SQL queries

## Prerequisites

- Docker Compose running
- `postgres` (main database, port 5432)
- `postgres-dev` (Atlas dev database, port 5433)

The dev database automatically loads `db/schema_pre.sql` on first startup via Docker init scripts.

## Daily Workflow

### 1. Make Schema Changes

Edit HCL files in `db/schema/`:

```bash
nvim db/schema/users.hcl
```

### 2. Generate Migration

```bash
task db:migrate:new -- descriptive_migration_name
```

This will:

- Use Atlas to diff your HCL schema against the dev database
- Generate a Goose migration file in `db/migrations/`

### 3. Apply Migration

```bash
task db:migrate:apply
```

This will:

- Apply `db/schema_pre.sql` (extensions, functions)
- Run pending Goose migrations
- Apply `db/schema_post.sql` (triggers, RLS policies)

### 4. Regenerate SQLC Code

```bash
task generate
```

This will:

- Inspect the live database to create `db/schema.sql`
- Generate type-safe Go code in `internal/db/`

## Combined Workflow

```bash
# Edit HCL files
nvim db/schema/users.hcl

# Generate migration, apply it, and regenerate SQLC
task schema:update -- descriptive_name
```

## Important Files

### Schema Definition

- `db/schema/*.hcl` - Atlas HCL schema files (source of truth)
- `db/schema_pre.sql` - Extensions and functions (applied before migrations)
- `db/schema_post.sql` - Triggers and RLS policies (applied after migrations)

### Generated

- `db/migrations/*.sql` - Goose migration files (generated by Atlas)
- `db/schema.sql` - SQL schema for SQLC (generated from live DB)
- `internal/db/*.go` - Type-safe Go code (generated by SQLC)

## Database Setup from Scratch

```bash
# 1. Start databases
docker compose up -d postgres postgres-dev

# 2. Wait for databases to be ready
task wait-for-db

# 3. Apply migrations
task db:migrate:apply

# 4. Generate SQLC code
task generate
```

## Dev Database Initialization

The `postgres-dev` database is used by Atlas for schema diffing. It automatically loads `db/schema_pre.sql` on first startup.

If you need to reinitialize it:

```bash
docker compose down postgres-dev
docker volume rm ai-gateway_atlas_dev_data
docker compose up -d postgres-dev
```

The init script (`/docker-entrypoint-initdb.d/01_schema_pre.sql`) will automatically run.

## Migration Status

```bash
# View migration status
task db:migrate:status

# View schema diff (Atlas)
task db:status
```

## Troubleshooting

### "Function does not exist" errors

The dev database needs `schema_pre.sql` loaded. This happens automatically on first startup. If you get this error:

```bash
docker compose restart postgres-dev
```

### "Database is not clean" errors

This means Atlas found tables in the dev database when expecting a clean state. Reinitialize:

```bash
task db:dev:init
```

### Migration conflicts

If you have merge conflicts in migration files, never edit them manually. Instead:

1. Backup your migrations: `cp -r db/migrations db/migrations_backup`
2. Resolve the HCL schema conflicts
3. Regenerate migrations from the resolved HCL schema

## Key Principles

1. **HCL files are the source of truth** - Edit these, not SQL
2. **Never edit generated migrations** - They're versioned and immutable
3. **Dev database stays clean** - Only has schema_pre.sql, no migrations applied
4. **Main database gets migrations** - Applied via Goose at runtime
5. **Extensions/functions in schema_pre.sql** - Not in HCL (requires Atlas Pro)

## CI/CD

Your `internal/migrate/migrate.go` handles migrations at application startup:

```go
migrate.InitDatabase(ctx, connectionString)
```

This runs:

1. `db/schema_pre.sql`
2. Goose migrations
3. `db/schema_post.sql`
