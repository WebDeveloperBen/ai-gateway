// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage_metrics.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUsageMetric = `-- name: CreateUsageMetric :one
INSERT INTO usage_metrics (
  org_id, app_id, api_key_id, model_id, provider, model_name,
  prompt_tokens, completion_tokens, total_tokens,
  request_size_bytes, response_size_bytes, timestamp
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, org_id, app_id, api_key_id, model_id, provider, model_name, prompt_tokens, completion_tokens, total_tokens, request_size_bytes, response_size_bytes, timestamp
`

type CreateUsageMetricParams struct {
	OrgID             uuid.UUID          `json:"org_id"`
	AppID             uuid.UUID          `json:"app_id"`
	ApiKeyID          uuid.UUID          `json:"api_key_id"`
	ModelID           *uuid.UUID         `json:"model_id"`
	Provider          string             `json:"provider"`
	ModelName         string             `json:"model_name"`
	PromptTokens      int32              `json:"prompt_tokens"`
	CompletionTokens  int32              `json:"completion_tokens"`
	TotalTokens       int32              `json:"total_tokens"`
	RequestSizeBytes  int32              `json:"request_size_bytes"`
	ResponseSizeBytes int32              `json:"response_size_bytes"`
	Timestamp         pgtype.Timestamptz `json:"timestamp"`
}

func (q *Queries) CreateUsageMetric(ctx context.Context, arg CreateUsageMetricParams) (UsageMetric, error) {
	row := q.db.QueryRow(ctx, createUsageMetric,
		arg.OrgID,
		arg.AppID,
		arg.ApiKeyID,
		arg.ModelID,
		arg.Provider,
		arg.ModelName,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.TotalTokens,
		arg.RequestSizeBytes,
		arg.ResponseSizeBytes,
		arg.Timestamp,
	)
	var i UsageMetric
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.AppID,
		&i.ApiKeyID,
		&i.ModelID,
		&i.Provider,
		&i.ModelName,
		&i.PromptTokens,
		&i.CompletionTokens,
		&i.TotalTokens,
		&i.RequestSizeBytes,
		&i.ResponseSizeBytes,
		&i.Timestamp,
	)
	return i, err
}

const getUsageByModel = `-- name: GetUsageByModel :many
SELECT
  model_name,
  provider,
  COALESCE(SUM(prompt_tokens), 0) as total_prompt_tokens,
  COALESCE(SUM(completion_tokens), 0) as total_completion_tokens,
  COALESCE(SUM(total_tokens), 0) as total_tokens,
  COUNT(*) as request_count
FROM usage_metrics
WHERE app_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
GROUP BY model_name, provider
ORDER BY total_tokens DESC
LIMIT $4 OFFSET $5
`

type GetUsageByModelParams struct {
	AppID       uuid.UUID          `json:"app_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetUsageByModelRow struct {
	ModelName             string      `json:"model_name"`
	Provider              string      `json:"provider"`
	TotalPromptTokens     interface{} `json:"total_prompt_tokens"`
	TotalCompletionTokens interface{} `json:"total_completion_tokens"`
	TotalTokens           interface{} `json:"total_tokens"`
	RequestCount          int64       `json:"request_count"`
}

func (q *Queries) GetUsageByModel(ctx context.Context, arg GetUsageByModelParams) ([]GetUsageByModelRow, error) {
	rows, err := q.db.Query(ctx, getUsageByModel,
		arg.AppID,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsageByModelRow
	for rows.Next() {
		var i GetUsageByModelRow
		if err := rows.Scan(
			&i.ModelName,
			&i.Provider,
			&i.TotalPromptTokens,
			&i.TotalCompletionTokens,
			&i.TotalTokens,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageMetricsByAPIKey = `-- name: GetUsageMetricsByAPIKey :many
SELECT id, org_id, app_id, api_key_id, model_id, provider, model_name, prompt_tokens, completion_tokens, total_tokens, request_size_bytes, response_size_bytes, timestamp FROM usage_metrics
WHERE api_key_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
ORDER BY timestamp DESC
`

type GetUsageMetricsByAPIKeyParams struct {
	ApiKeyID    uuid.UUID          `json:"api_key_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

func (q *Queries) GetUsageMetricsByAPIKey(ctx context.Context, arg GetUsageMetricsByAPIKeyParams) ([]UsageMetric, error) {
	rows, err := q.db.Query(ctx, getUsageMetricsByAPIKey, arg.ApiKeyID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsageMetric
	for rows.Next() {
		var i UsageMetric
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.AppID,
			&i.ApiKeyID,
			&i.ModelID,
			&i.Provider,
			&i.ModelName,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.TotalTokens,
			&i.RequestSizeBytes,
			&i.ResponseSizeBytes,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageMetricsByApp = `-- name: GetUsageMetricsByApp :many
SELECT id, org_id, app_id, api_key_id, model_id, provider, model_name, prompt_tokens, completion_tokens, total_tokens, request_size_bytes, response_size_bytes, timestamp FROM usage_metrics
WHERE app_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
ORDER BY timestamp DESC
LIMIT $4 OFFSET $5
`

type GetUsageMetricsByAppParams struct {
	AppID       uuid.UUID          `json:"app_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetUsageMetricsByApp(ctx context.Context, arg GetUsageMetricsByAppParams) ([]UsageMetric, error) {
	rows, err := q.db.Query(ctx, getUsageMetricsByApp,
		arg.AppID,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsageMetric
	for rows.Next() {
		var i UsageMetric
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.AppID,
			&i.ApiKeyID,
			&i.ModelID,
			&i.Provider,
			&i.ModelName,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.TotalTokens,
			&i.RequestSizeBytes,
			&i.ResponseSizeBytes,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageMetricsByOrg = `-- name: GetUsageMetricsByOrg :many
SELECT id, org_id, app_id, api_key_id, model_id, provider, model_name, prompt_tokens, completion_tokens, total_tokens, request_size_bytes, response_size_bytes, timestamp FROM usage_metrics
WHERE org_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
ORDER BY timestamp DESC
`

type GetUsageMetricsByOrgParams struct {
	OrgID       uuid.UUID          `json:"org_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

func (q *Queries) GetUsageMetricsByOrg(ctx context.Context, arg GetUsageMetricsByOrgParams) ([]UsageMetric, error) {
	rows, err := q.db.Query(ctx, getUsageMetricsByOrg, arg.OrgID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsageMetric
	for rows.Next() {
		var i UsageMetric
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.AppID,
			&i.ApiKeyID,
			&i.ModelID,
			&i.Provider,
			&i.ModelName,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.TotalTokens,
			&i.RequestSizeBytes,
			&i.ResponseSizeBytes,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumTokensByApp = `-- name: SumTokensByApp :one
SELECT
  COALESCE(SUM(prompt_tokens), 0) as total_prompt_tokens,
  COALESCE(SUM(completion_tokens), 0) as total_completion_tokens,
  COALESCE(SUM(total_tokens), 0) as total_tokens,
  COUNT(*) as request_count
FROM usage_metrics
WHERE app_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
`

type SumTokensByAppParams struct {
	AppID       uuid.UUID          `json:"app_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

type SumTokensByAppRow struct {
	TotalPromptTokens     interface{} `json:"total_prompt_tokens"`
	TotalCompletionTokens interface{} `json:"total_completion_tokens"`
	TotalTokens           interface{} `json:"total_tokens"`
	RequestCount          int64       `json:"request_count"`
}

func (q *Queries) SumTokensByApp(ctx context.Context, arg SumTokensByAppParams) (SumTokensByAppRow, error) {
	row := q.db.QueryRow(ctx, sumTokensByApp, arg.AppID, arg.Timestamp, arg.Timestamp_2)
	var i SumTokensByAppRow
	err := row.Scan(
		&i.TotalPromptTokens,
		&i.TotalCompletionTokens,
		&i.TotalTokens,
		&i.RequestCount,
	)
	return i, err
}

const sumTokensByOrg = `-- name: SumTokensByOrg :one
SELECT
  COALESCE(SUM(prompt_tokens), 0) as total_prompt_tokens,
  COALESCE(SUM(completion_tokens), 0) as total_completion_tokens,
  COALESCE(SUM(total_tokens), 0) as total_tokens,
  COUNT(*) as request_count
FROM usage_metrics
WHERE org_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
`

type SumTokensByOrgParams struct {
	OrgID       uuid.UUID          `json:"org_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

type SumTokensByOrgRow struct {
	TotalPromptTokens     interface{} `json:"total_prompt_tokens"`
	TotalCompletionTokens interface{} `json:"total_completion_tokens"`
	TotalTokens           interface{} `json:"total_tokens"`
	RequestCount          int64       `json:"request_count"`
}

func (q *Queries) SumTokensByOrg(ctx context.Context, arg SumTokensByOrgParams) (SumTokensByOrgRow, error) {
	row := q.db.QueryRow(ctx, sumTokensByOrg, arg.OrgID, arg.Timestamp, arg.Timestamp_2)
	var i SumTokensByOrgRow
	err := row.Scan(
		&i.TotalPromptTokens,
		&i.TotalCompletionTokens,
		&i.TotalTokens,
		&i.RequestCount,
	)
	return i, err
}
